;
; PIO 82C55 I/O IS DECODED TO PORT 60-67
;
PIOA		.EQU 	60H		; PORT A
PIOB		.EQU 	61H		; PORT B
PIOC		.EQU 	62H		; PORT C
PIOX	 	.EQU 	63H		; PIO CONTROL PORT
;
CPUFREQ	.EQU	20
;
	.ORG	$100
	; SAVE PREVIOUS STACK POINTER, AND SWITCH TO OUR STACK
	LD	(STACKSAV),SP
	LD	SP,STACK
	
	LD	DE,PPPSTR_BANNER
	CALL	WRITESTR

	LD	DE,PPPSTR_INTRO
	CALL	WRITESTR

	LD	DE,PPPSTR_CONFIRM
	CALL	WRITESTR
	
CONF:
	CALL	CIN
	CP	$1B
	JR	Z,EXIT
	CP	$0D
	JR	NZ,CONF
	
	; INITIALIZATION
	CALL	INIT
	
	; PERFORM TESTS
	CALL	RUNTESTS

EXIT:	
	; CLEAN UP AND RETURN TO OS
	CALL	NEWLINE
	CALL	NEWLINE
	LD	SP,(STACKSAV)
	
	RET
	
INIT:
	LD	DE,PPPSTR_INIT
	CALL	WRITESTR
	
	LD	A,$9B			; PPI MODE 0, ALL PINS INPUT
	OUT	(PIOX),A		; SEND IT

	LD	A,11000010B		; PPI MODE 2 (BI HANDSHAKE), PC0-2 OUT, PB IN
	OUT	(PIOX),A
	CALL	PC_PERIOD
	
	CALL	DELAY			; PROBABLY NOT NEEDED
	
	LD	A,00000000B		; SET PC0 -> 0
	OUT	(PIOX),A
	LD	A,00000010B		; SET PC1 -> 0
	OUT	(PIOX),A
	LD	A,00000101B		; SET PC2 -> 1 - ASSERT RESET ON PPP
	OUT	(PIOX),A
	LD	A,00000110B		; SET PC3 -> 0
	OUT	(PIOX),A
	CALL	PC_PERIOD
	
	CALL	DELAY			; PROBABLY NOT NEEDED
	
	IN	A,(PIOA)		; CLEAR GARBAGE???
	CALL	PC_PERIOD
	
	CALL	DELAY			; PROBABLY NOT NEEDED
	
	LD	A,00000001B	; SET CMD FLAG
	OUT	(PIOX),A	; SEND IT
	LD	C,$F0
	CALL	PUTBYTE		; SEND THE COMMAND BYTE
	CALL	DELAY
	LD	A,00000000B	; CLEAR CMD FLAG
	OUT	(PIOX),A
	
	LD	A,00000100B		; SET PC2 -> 0 - DEASSERT RESET ON PPP
	OUT	(PIOX),A
	
	CALL	DELAY			; PROBABLY NOT NEEDED
	
INIT0:
	LD	BC,0
INIT1:
	PUSH	BC
	CALL	DELAY
	CALL	DELAY
	CALL	DELAY
	CALL	DELAY
	IN	A,(PIOA)
	POP	BC
	CP	$AA
	JR	Z,INIT2
	DEC	BC
	LD	A,B
	OR	C
	JR	NZ,INIT1
	
	LD	DE,PPPSTR_TIMEOUT
	CALL	WRITESTR
	CALL	PC_SPACE
	LD	A,1
	CALL	PRTHEXBYTE
	CALL	NEWLINE
	SCF
	RET

INIT2:

	LD	DE,PPPSTR_OK
	CALL	WRITESTR
	
	XOR	A
	RET
	
RUNTESTS:
	CALL	TEST1
	RET	C
	
	CALL	TEST2
	RET	C
	
	CALL	TEST3
	RET	C
	
	CALL	TEST4
	RET	C
	
	CALL	TEST5
	RET	C
	
	CALL	TEST6
	RET	C
	
	CALL	TEST7
	RET	C
	
	CALL	TEST8
	RET	C
	
	CALL	TEST9
	RET	C
	
	RET
	
TEST1:
	LD	DE,PPPSTR_BYTEECHO
	CALL	WRITESTR

	LD	B,$10
	LD	C,$AA
TEST1A:
	PUSH	BC
	CALL	DOECHO
	POP	BC
	JR	NZ,TEST1_ERR
	CALL	PC_PERIOD
	LD	A,C
	XOR	$FF
	LD	C,A
	DJNZ	TEST1A

	LD	DE,PPPSTR_OK
	CALL	WRITESTR
	
	XOR	A
	RET

TEST1_ERR:
	LD	DE,PPPSTR_CMPERR
	CALL	WRITESTR
	SCF
	RET
	
DOECHO:
	PUSH	BC
	LD	C,1		; CMD=ECHOBYTE
	CALL	SENDCMD
	POP	BC

	LD	D,C
	CALL	PUTBYTE
	CALL	GETBYTE
	LD	A,C
	XOR	$FF
	CP	D
	RET
	
TEST2:
	LD	DE,PPPSTR_BUFECHO
	CALL	WRITESTR

	LD	B,$10
TEST2A:
	PUSH	BC
	CALL	DOBUFECHO
	POP	BC
	JR	NZ,TEST2_ERR
	CALL	PC_PERIOD
	DJNZ	TEST2A

	LD	DE,PPPSTR_OK
	CALL	WRITESTR
	
	XOR	A
	RET
	
TEST2_ERR:
	LD	DE,PPPSTR_CMPERR
	CALL	WRITESTR
	CALL	NEWLINE
	LD	DE,SECBUF
	CALL	DUMP_BUFFER
	SCF
	RET
	
DOBUFECHO:
	LD	C,2		; COMMAND = ECHOBUF
	CALL	SENDCMD
	
	CALL	PAT_BUFFER
	CALL	SAVE_BUFFER
	CALL	PUTBUF
	CALL	FILL_BUFFER
	CALL	GETBUF
	CALL	CMP_BUFFER
	RET
	
PUTBUF:
	LD	BC,512
	LD	HL,SECBUF
PUTBUF1:
	PUSH	BC
	LD	A,(HL)
	INC	HL
	LD	C,A
	CALL	PUTBYTE
	POP	BC
	DEC	BC
	LD	A,B
	OR	C
	JP	NZ,PUTBUF1
	RET
	
GETBUF:
	LD	BC,512
	LD	HL,SECBUF
GETBUF1:
	PUSH	BC
	CALL	GETBYTE
	LD	A,C
	LD	(HL),A
	INC	HL
	POP	BC
	DEC	BC
	LD	A,B
	OR	C
	JP	NZ,GETBUF1
	RET
	
TEST3:
	LD	DE,PPPSTR_ABTTST
	CALL	WRITESTR
	
	LD	C,$12
	CALL	SENDCMD
	LD	BC,500			; UNDERFLOW ON PUTBUF
	LD	HL,SECBUF
	CALL	PUTBUF1
	LD	C,0
	CALL	SENDCMD
	CALL	PC_PERIOD
	
	LD	C,$12
	CALL	SENDCMD
	LD	BC,600			; OVERFLOW ON PUTBUF
	LD	HL,SECBUF
	CALL	PUTBUF1
	LD	C,0
	CALL	SENDCMD
	CALL	PC_PERIOD

	LD	C,$13
	CALL	SENDCMD
	LD	BC,500			; UNDERFLOW ON GETBUF
	LD	HL,SECBUF
	CALL	GETBUF1
	LD	C,0
	CALL	SENDCMD
	CALL	PC_PERIOD
	
	LD	DE,PPPSTR_OK
	CALL	WRITESTR
	
	XOR	A
	RET

TEST4:
	LD	DE,PPPSTR_DISKRW
	CALL	WRITESTR

	CALL	DSKRESET
	JR	NZ,TEST4_IOERR
	CALL	PC_PERIOD

	CALL	PAT_BUFFER
	CALL	SAVE_BUFFER

	LD	B,$10
TEST4A:
	PUSH	BC
	LD	BC,0
	LD	(PPP_LBAHI),BC
	CALL	RNDBYTE
	LD	C,A
	LD	(PPP_LBALO),BC
	CALL	DSKRW
	POP	BC
	JR	NZ,TEST4_IOERR
	PUSH	BC
	CALL	CMP_BUFFER
	POP	BC
	JR	NZ,TEST4_CMPERR
	CALL	PC_PERIOD
	DJNZ	TEST4A
	
	LD	DE,PPPSTR_OK
	CALL	WRITESTR
	
	XOR	A
	RET

TEST4_IOERR:
	LD	DE,PPPSTR_IOERR
	CALL	WRITESTR

	LD	DE,PPPSTR_DSKSTAT
	CALL	WRITESTR

	CALL	DSKSTAT
	LD	BC,(PPP_DSKSTHI)
	LD	A,B
	CALL	PRTHEXBYTE
	LD	A,C
	CALL	PRTHEXBYTE
	LD	BC,(PPP_DSKSTLO)
	LD	A,B
	CALL	PRTHEXBYTE
	LD	A,C
	CALL	PRTHEXBYTE

	SCF
	RET
	
TEST4_CMPERR:
	LD	DE,PPPSTR_CMPERR
	CALL	WRITESTR
	LD	DE,SECBUF
	CALL	DUMP_BUFFER
	SCF
	RET
	
TEST5:
	LD	DE,PPPSTR_VIDEO
	CALL	WRITESTR
	
	LD	C,CHR_CR
	CALL	VIDOUT
	LD	C,CHR_LF
	CALL	VIDOUT
	
	LD	B,26
	LD	C,'A' - 1
TEST5A:
	LD	A,C
	INC	A
	LD	C,A
	PUSH	BC
	CALL	VIDOUT
	POP	BC
	CALL	PC_PERIOD
	DJNZ	TEST5A
	
	LD	C,CHR_CR
	CALL	VIDOUT
	LD	C,CHR_LF
	CALL	VIDOUT
	
	LD	DE,PPPSTR_OK
	CALL	WRITESTR
	
	XOR	A
	RET
	
TEST6:
	LD	DE,PPPSTR_KEYBOARD
	CALL	WRITESTR
	
	LD	HL,PPSTR_KBDPRMPT
TEST6X:
	LD	A,(HL)
	INC	HL
	CP	'$'
	JR	Z,TEST6A
	LD	C,A
	CALL	VIDOUT
	JR	TEST6X

TEST6A:	
	CALL	KBDIN
	LD	A,C
	CP	$1B
	JR	Z,TEST6B
	CALL	PC_PERIOD
	CALL	VIDOUT
	JR	TEST6A

TEST6B:
	LD	C,CHR_CR
	CALL	VIDOUT
	LD	C,CHR_LF
	CALL	VIDOUT

	LD	DE,PPPSTR_OK
	CALL	WRITESTR
	
	XOR	A
	RET
	
TEST7:
	LD	DE,PPPSTR_SPEAKER
	CALL	WRITESTR
	
	LD	B,16
TEST7A:
	DJNZ	TEST7B
	JR	TEST7C
TEST7B:
	PUSH	BC
	LD	C,$40	; SPEAKER TONE
	CALL	SENDCMD
	
	LD	A,B
	RLCA
	RLCA
	RLCA
	RLCA
	LD	C,A
	CALL	PUTBYTE
	LD	C,16	; DURATION = 16/256 = 1/16 SEC
	CALL	PUTBYTE
	CALL	PC_PERIOD
	POP	BC
	JR	TEST7A
	
TEST7C:
	LD	DE,PPPSTR_OK
	CALL	WRITESTR
	
	XOR	A
	RET
	
TEST8:
	LD	DE,PPPSTR_SIOLOOP
	CALL	WRITESTR
	
	LD	C,$55		; RX FLUSH
	CALL	SENDCMD
	
	LD	B,26
	LD	C,'A' - 1
TEST8A:
	LD	A,C
	INC	A
	LD	C,A
	PUSH	BC
	CALL	SIOTX
	CALL	SIORX
	LD	A,C
	POP	BC
	CP	C
	JR	NZ,TEST8_CMPERR

	CALL	PC_PERIOD
	DJNZ	TEST8A
	
	LD	DE,PPPSTR_OK
	CALL	WRITESTR
	
	XOR	A
	RET

TEST8_CMPERR:
	PUSH	AF
	PUSH	BC
	LD	DE,PPPSTR_CMPERR
	CALL	WRITESTR
	CALL	PC_COLON
	POP	BC
	LD	A,C
	CALL	PRTHEXBYTE
	CALL	PC_SPACE
	POP	AF
	CALL	PRTHEXBYTE
	
	SCF
	RET
	

	
TEST9:
	LD	DE,PPPSTR_SIOBUF
	CALL	WRITESTR
	
	LD	C,$55		; RX FLUSH
	CALL	SENDCMD
	
	;LD	C,$53		; SERIAL RX STAT
	;CALL	SENDCMD
	;CALL	GETBYTE
	;CALL	PRTHEXBYTE
	;CALL	PC_SPACE
	
	;LD	C,$54		; SERIAL TX STAT
	;CALL	SENDCMD
	;CALL	GETBYTE
	;CALL	PRTHEXBYTE
	;CALL	PC_SPACE
	
	LD	C,'X'
	CALL	SIOTX
	CALL	PC_PERIOD
	CALL	SIOTX
	CALL	PC_PERIOD
	CALL	SIOTX
	CALL	PC_PERIOD
	CALL	SIOTX
	CALL	PC_PERIOD
	CALL	SIOTX
	CALL	PC_PERIOD
	CALL	SIOTX
	CALL	PC_PERIOD
	CALL	SIOTX
	CALL	PC_PERIOD
	CALL	SIOTX
	CALL	PC_PERIOD
	
	;LD	C,$54		; SERIAL TX STAT
	;CALL	SENDCMD
	;CALL	GETBYTE
	;CALL	PRTHEXBYTE
	;CALL	PC_SPACE
	
	CALL	LDELAY

	LD	C,$53		; SERIAL RX STAT
	CALL	SENDCMD
	CALL	GETBYTE
	LD	A,8
	CP	C
	JR	NZ,TEST9_CMPERR

	LD	DE,PPPSTR_OK
	CALL	WRITESTR
	
	XOR	A
	RET
	
TEST9_CMPERR:
	PUSH	BC
	LD	DE,PPPSTR_CMPERR
	CALL	WRITESTR
	CALL	PC_COLON
	POP	BC
	LD	A,C
	CALL	PRTHEXBYTE
	
	SCF
	RET
	
KBDIN:
	LD	C,$31
	CALL	SENDCMD
	CALL	GETBYTE
	LD	A,C
	RET
	
SIOTX:
	PUSH	BC
	LD	C,$52
	CALL	SENDCMD
	POP	BC

	CALL	PUTBYTE
	RET
	
SIORX:
	LD	C,$51
	CALL	SENDCMD

	CALL	GETBYTE
	RET

VIDOUT:
	PUSH	BC
	LD	C,$20
	CALL	SENDCMD
	POP	BC

	CALL	PUTBYTE
	RET
	
DSKRW:
	CALL	FILL_BUFFER
	CALL	DSKWRITE
	RET	NZ

	CALL	FILL_BUFFER
	CALL	DSKREAD
	RET	NZ
	
	CALL	PAT_BUFFER
	CALL	DSKWRITE
	RET	NZ

	CALL	FILL_BUFFER
	CALL	DSKREAD
	RET	NZ
	
	XOR	A
	RET

DSKRESET
	; RESET & STATUS DISK
	LD	C,$10		; COMMAND = DSKRESET
	CALL	SENDCMD
	
	CALL	GETBYTE
	LD	A,C
	;CALL	PRTHEXBYTE
	OR	A
	
	RET

DSKSTAT:	
	LD	C,$11		; COMMAND = DSKSTAT
	CALL	SENDCMD
	
	LD	HL,PPP_DSKSTAT
	CALL	GETBYTEA
	LD	(HL),A
	INC	HL
	CALL	GETBYTEA
	LD	(HL),A
	INC	HL
	CALL	GETBYTEA
	LD	(HL),A
	INC	HL
	CALL	GETBYTEA
	LD	(HL),A
	INC	HL
	
	RET

DSKREAD:	
	; READ A SECTOR
	LD	C,$14		; COMMAND = DSKRD
	CALL	SENDCMD

	LD	HL,PPP_LBA
	LD	A,(HL)
	INC	HL
	CALL	PUTBYTEA
	LD	A,(HL)
	INC	HL
	CALL	PUTBYTEA
	LD	A,(HL)
	INC	HL
	CALL	PUTBYTEA
	LD	A,(HL)
	INC	HL
	CALL	PUTBYTEA

	CALL	GETBYTEA		; GET RESULT
	
	;CALL	PRTHEXBYTE
	OR	A
	RET	NZ
	
	LD	C,$13		; COMMAND = DSKGET
	CALL	SENDCMD

	LD	BC,512
	LD	HL,SECBUF
DSKREAD1:
	PUSH	BC
	CALL	GETBYTEA
	LD	(HL),A
	INC	HL
	POP	BC
	DEC	BC
	LD	A,B
	OR	C
	JP	NZ,DSKREAD1

	RET
	
DSKWRITE:	
	; WRITE A SECTOR
	LD	C,$12		; COMMAND = DSKPUT
	CALL	SENDCMD

	LD	BC,512
	LD	HL,SECBUF
DSKWRITE1:
	PUSH	BC
	LD	A,(HL)
	INC	HL
	CALL	PUTBYTEA
	POP	BC
	DEC	BC
	LD	A,B
	OR	C
	JP	NZ,DSKWRITE1

	LD	C,$15		; COMMAND = DSKWR
	CALL	SENDCMD

	LD	HL,PPP_LBA
	LD	A,(HL)
	INC	HL
	CALL	PUTBYTEA
	LD	A,(HL)
	INC	HL
	CALL	PUTBYTEA
	LD	A,(HL)
	INC	HL
	CALL	PUTBYTEA
	LD	A,(HL)
	INC	HL
	CALL	PUTBYTEA
	

	CALL	GETBYTEA		; GET RESULT

	;CALL	PRTHEXBYTE
	OR	A
	RET	NZ
	
	OR	A
	RET
	
SENDCMD:
	IN	A,(PIOA)	; DISCARD ANYTHING PENDING
	; WAIT FOR OBF HIGH (OUTPUT BUFFER TO BE EMPTY)
	IN	A,(PIOC)
	BIT	7,A
	JR	Z,SENDCMD

	LD	A,00000001B	; SET CMD FLAG
	OUT	(PIOX),A	; SEND IT
	CALL	PUTBYTE		; SEND THE COMMAND BYTE
SENDCMD1:
	; WAIT FOR OBF HIGH (BYTE HAS BEEN RECEIVED)
	IN	A,(PIOC)
	BIT	7,A
	JR	Z,SENDCMD1
	; TURN OFF CMD
	LD	A,00000000B	; CLEAR CMD FLAG
	OUT	(PIOX),A
	
	RET
	
PUTWAIT:
	; WAIT FOR OBF HIGH (BYTE HAS BEEN RECEIVED)
	IN	A,(PIOC)
	BIT	7,A
	JR	Z,PUTWAIT
	RET

PUTBYTE:
	IN	A,(PIOC)
	BIT	7,A
	JR	Z,PUTBYTE
	LD	A,C
	OUT	(PIOA),A
	RET
	
PUTBYTEA:
	PUSH	BC
	LD	C,A
	CALL	PUTBYTE
	POP	BC
	RET
	
GETBYTE:
	IN	A,(PIOC)
	BIT	5,A
	JR	Z,GETBYTE
	IN	A,(PIOA)
	LD	C,A
	RET

GETBYTEA:
	PUSH	BC
	CALL	GETBYTE
	LD	A,C
	POP	BC
	RET
;
;
;
PPP_LBA:
PPP_LBALO	.DW	0
PPP_LBAHI	.DW	0
PPP_DSKSTAT:
PPP_DSKSTLO	.DW	0
PPP_DSKSTHI	.DW	0
;
PPPSTR_INIT	.TEXT	"\r\nInitializing$"
PPPSTR_BYTEECHO	.TEXT	"\r\nByte echo$"
PPPSTR_BUFECHO	.TEXT	"\r\nBuffer echo$"
PPPSTR_ABTTST	.TEXT	"\r\nAbort command test$"
PPPSTR_DISKRW	.TEXT	"\r\nDisk Read/Write$"
PPPSTR_VIDEO	.TEXT	"\r\nVideo$"
PPPSTR_KEYBOARD	.TEXT	"\r\nKeyboard$"
PPPSTR_SPEAKER	.TEXT	"\r\nSpeaker$"
PPPSTR_SIOLOOP	.TEXT	"\r\nSerial Port Loopback$"
PPPSTR_SIOBUF	.TEXT	"\r\nSerial Port Buffer$"
PPPSTR_CMPERR	.TEXT	"\r\n*COMPARE ERROR*$"
PPPSTR_IOERR	.TEXT	"\r\n*IO ERROR*$"
PPPSTR_DSKSTAT	.TEXT	"\r\nDISK STATUS=$"
PPPSTR_OK	.TEXT	"OK$"
PPPSTR_TIMEOUT	.TEXT	"TIMEOUT!$"
PPPSTR_CMD	.TEXT	"CMD=$"
PPPSTR_RSP	.TEXT	"RESP=$"
PPSTR_KBDPRMPT	.TEXT	"\r\nPress keys on keyboard, <esc> to exit\r\n$"
PPSTR_SIOPRMPT	.TEXT	"\r\nPress keys on serial terminal, <esc> to exit\r\n$"
PPPSTR_BANNER	.TEXT	"\r\nParPortProp Hardware Validation v0.9\r\n\r\n$"
PPPSTR_INTRO	.TEXT	"Instructions:\r\n"
		.TEXT	"  - Program ParPortProp with ParPortProp.eeprom\r\n"
		.TEXT	"  - Insert SD Card (EXISTING DATA WILL BE DESTROYED!!!)\r\n"
		.TEXT	"  - Attach a VGA monitor and PS/2 keyboard\r\n"
		.TEXT	"  - Cross connect pins 2 & 3 of DE-9 serial port connector\r\n"
		.TEXT	"  - Press <Esc> on keyboard to end keyboard test\r\n$"
PPPSTR_CONFIRM	.TEXT	"\r\nPress <Enter> to continue, <Esc> to abort$"

;
;==================================================================================================
; UTILITY FUNCTIONS
;==================================================================================================
;
;
CHR_CR		.EQU	0DH
CHR_LF		.EQU	0AH
CHR_BS		.EQU	08H
CHR_ESC		.EQU	1BH
;
;__________________________________________________________________________________________________
;
; UTILITY PROCS TO PRINT SINGLE CHARACTERS WITHOUT TRASHING ANY REGISTERS
;
PC_SPACE:
	PUSH	AF
	LD	A,' '
	JR	PC_PRTCHR

PC_PERIOD:
	PUSH	AF
	LD	A,'.'
	JR	PC_PRTCHR

PC_COLON:
	PUSH	AF
	LD	A,':'
	JR	PC_PRTCHR

PC_LBKT:
	PUSH	AF
	LD	A,'['
	JR	PC_PRTCHR

PC_RBKT:
	PUSH	AF
	LD	A,']'
	JR	PC_PRTCHR

PC_CR:
	PUSH	AF
	LD	A,CHR_CR
	JR	PC_PRTCHR

PC_LF:
	PUSH	AF
	LD	A,CHR_LF
	JR	PC_PRTCHR

PC_PRTCHR:
	CALL	COUT
	POP	AF
	RET

NEWLINE:
	CALL	PC_CR
	CALL	PC_LF
	RET
;
; PRINT THE HEX BYTE VALUE IN A
;
PRTHEXBYTE:
	PUSH	AF
	PUSH	DE
	LD	DE,HEXSTRBUF
	CALL	HEXSTRBYTE
	LD	A,'$'
	LD	(DE),A
	LD	DE,HEXSTRBUF
	CALL	WRITESTR
	POP	DE
	POP	AF
	RET
;
; PRINT THE HEX WORD VALUE IN BC
;
PRTHEXWORD:
	PUSH	AF
	LD	A,B
	CALL	PRTHEXBYTE
	LD	A,C
	CALL	PRTHEXBYTE
	POP	AF
	RET
;
; CONVERT VALUE IN A TO A 2 CHARACTER HEX STRING AT DE
;
HEXCHR	.TEXT	"0123456789ABCDEF"
;
HEXSTRBYTE:
	PUSH	BC
	PUSH	HL
	PUSH	AF
	LD	BC,0
	RRA
	RRA
	RRA
	RRA
	AND	0FH
	LD	C,A
	LD	HL,HEXCHR
	ADD	HL,BC
	LD	A,(HL)
	LD	(DE),A
	INC	DE
	POP	AF
	PUSH	AF
	LD	BC,0
	AND	0FH
	LD	C,A
	LD	HL,HEXCHR
	ADD	HL,BC
	LD	A,(HL)
	LD	(DE),A
	INC	DE
	POP	AF
	POP	HL
	POP	BC
	RET
;
; CONVERT VALUE IN BC TO A 4 CHARACTER HEX STRING AT DE
;
HEXSTRWORD:
	LD	A,B
	CALL	HEXSTRBYTE
	LD	A,C
	CALL	HEXSTRBYTE
	RET

;
; PRINT A BYTE BUFFER IN HEX POINTED TO BY DE
; REGISTER A HAS SIZE OF BUFFER
;
PRTHEXBUF:
	CP	0		; EMPTY BUFFER?
	JP	Z,PRTHEXBUF2
	
	LD	B,A
PRTHEXBUF1:
	CALL	PC_SPACE
	LD	A,(DE)
	CALL	PRTHEXBYTE
	INC	DE
	DJNZ	PRTHEXBUF1
	JP	PRTHEXBUFX
	
PRTHEXBUF2:
	CALL	PC_SPACE
	LD	DE,STR_EMPTY
	CALL	WRITESTR

PRTHEXBUFX:
	RET
;
; OUTPUT A '$' TERMINATED STRING
;
WRITESTR:
	LD	A,(DE)
	CP	'$'			; TEST FOR STRING TERMINATOR
	RET	Z			; DONE
	CALL	COUT
	INC	DE
	JP	WRITESTR		; TRANSMIT LOOP
;
; PANIC: TRY TO DUMP MACHINE STATE AND HALT
;
PANIC:
	PUSH	HL
	PUSH	DE
	PUSH	BC
	PUSH	AF
	LD	DE,STR_PANIC
	CALL	WRITESTR
	LD	DE,STR_AF
	CALL	WRITESTR
	POP	BC
	CALL	PRTHEXWORD
	LD	DE,STR_BC
	CALL	WRITESTR
	POP	BC
	CALL	PRTHEXWORD
	LD	DE,STR_DE
	CALL	WRITESTR
	POP	BC
	CALL	PRTHEXWORD
	LD	DE,STR_HL
	CALL	WRITESTR
	POP	BC
	CALL	PRTHEXWORD
	LD	DE,STR_PC
	CALL	WRITESTR
	POP	BC
	CALL	PRTHEXWORD
	JP	0
;
STR_PANIC	.DB	"\r\n\r\n>>> FATAL ERROR:$"
STR_AF		.DB	" AF=$"
STR_BC		.DB	" BC=$"
STR_DE		.DB	" DE=$"
STR_HL		.DB	" HL=$"
STR_PC		.DB	" PC=$"
;
; INDIRECT JUMP TO ADDRESS IN HL
;
;   MOSTLY USEFUL TO PERFORM AN INDIRECT CALL LIKE:
;     LD	HL,xxxx
;     CALL	JPHL
;
JPHL:	JP	(HL)
;
; DELAY ABOUT 25us (100 TSTATES INCLUDING CALL AND RET)
;
;	TOTAL T STATES = ((B*13) + 51)
;	4MHZ CPU, B=4, 103 T STATES = 25.75us
;	8MHZ CPU, B=12, 207 TSTATES = 25.875us
;	B = ((2 * FREQ) - 4)
;
DELAY:					; 17 T STATES (FOR CALL)
	PUSH	BC			; 11 T STATES
	LD	B,((CPUFREQ * 2)  - 4)	; 8 T STATES
	DJNZ	$			; (B*13) - 5 T STATES
	POP	BC			; 10 T STATES
	RET				; 10 T STATES
;
; DELAY 25us * VALUE IN DE (VARIABLE DELAY)
;
VDELAY:
	CALL	DELAY
	DEC	DE
	LD	A,D
	OR	E
	JP	NZ,VDELAY
	RET
;
; DELAY ABOUT 0.5 SECONDS = 25us * 20,000
;
LDELAY:
	PUSH	DE
	LD	DE,20000
	CALL	VDELAY
	POP	DE
	RET
;
; COUT
;
COUT_BUFFER	.TEXT	" $"
;
COUT:
	PUSH	BC			;
	PUSH	AF			;
	PUSH	HL			;
	PUSH	DE			;
	LD	(COUT_BUFFER),A		;
	LD	DE,COUT_BUFFER		;
	LD	C,09H			; CP/M WRITE START STRING TO CONSOLE CALL
	CALL	0005H
	POP	DE			;
	POP	HL			;
	POP	AF			;
	POP	BC			;
	RET				; DONE
;
; INPUT CHARACTER TO A
;
CIN:
	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	C,01H
	CALL	0005H
	POP	HL
	POP	DE
	POP	BC
	RET
;
; PRINT A BLOCK OF MEMORY NICELY FORMATTED
;  DE=BUFFER ADDRESS
;
DUMP_BUFFER:
	CALL	NEWLINE

	PUSH	DE
	POP	HL
	INC	D
	INC	D
	
BLKRD:
	CALL	PHL			; PRINT START LOCATION
	LD	C,16			; SET FOR 16 LOCS
	PUSH	HL			; SAVE STARTING HL
NXTONE:
	LD 	A,(HL)			; GET BYTE
	CALL	PRTHEXBYTE		; PRINT IT
	CALL	PC_SPACE		;
UPDH:	
	INC	HL			; POINT NEXT
	DEC	C			; DEC. LOC COUNT
	JR	NZ,NXTONE		; IF LINE NOT DONE
					; NOW PRINT 'DECODED' DATA TO RIGHT OF DUMP
PCRLF:
	CALL	PC_SPACE		; SPACE IT
	LD	C,16			; SET FOR 16 CHARS
	POP	HL			; GET BACK START
PCRLF0:
	LD	A,(HL)			; GET BYTE
	AND	060H			; SEE IF A 'DOT'
	LD	A,(HL)			; O.K. TO GET
	JR	NZ,PDOT			;
DOT:
	LD	A,2EH			; LOAD A DOT	
PDOT:
	CALL	COUT			; PRINT IT
	INC	HL			; 
	LD	A,D			;
	CP	H			;
	JR	NZ,UPDH1		;
	LD	A,E			;
	CP	L			;
	JP	Z,DUMP_END		;
;
;IF BLOCK NOT DUMPED, DO NEXT CHARACTER OR LINE
UPDH1:
	DEC	C			; DEC. CHAR COUNT
	JR	NZ,PCRLF0		; DO NEXT
CONTD:
	CALL	NEWLINE			;
	JP	BLKRD			;

DUMP_END:	
	RET				;
;__PHL_________________________________________________________________________________________________________________________ 
;
;	PRINT THE HL REG ON THE SERIAL PORT
;________________________________________________________________________________________________________________________________
;
PHL:
	LD	A,H			; GET HI BYTE
	CALL	PRTHEXBYTE		; DO HEX OUT ROUTINE
	LD	A,L			; GET LOW BYTE
	CALL	PRTHEXBYTE		; HEX IT
	CALL	PC_SPACE
	RET				; DONE  

;
; CLEAR BUFFER WITH $00
;
CLR_BUFFER:
	LD	HL,SECBUF
	LD	BC,BUFSIZ
CLR_BUFFER1:
	LD	A,0
	LD	(HL),A
	INC	HL
	DEC	BC
	LD	A,B
	OR	C
	JP	NZ,CLR_BUFFER1
	RET
;
; INITIALIZE BUFFER WITH FILLER BYTE $FF
;
FILL_BUFFER:
	LD	HL,SECBUF
	LD	BC,BUFSIZ
FILL_BUFFER1:
	LD	A,0FFH
	LD	(HL),A
	INC	HL
	DEC	BC
	LD	A,B
	OR	C
	JP	NZ,FILL_BUFFER1
	RET
;
; INITIALIZE BUFFER WITH PATTERN 00-FF
;
PAT_BUFFER:
	LD	HL,SECBUF
	LD	BC,BUFSIZ
	LD	D,0
PAT_BUFFER1:
	LD	A,D
	LD	(HL),A
	INC	HL
	DEC	BC
	INC	D
	LD	A,B
	OR	C
	JP	NZ,PAT_BUFFER1
	RET
;
; INITIALIZE BUFFER WITH RANDOM BYTES
;   HL = ADDRESS OF BUFFER
;   DE = SIZE OF BUFFER
;
RND_BUFFER:
	LD	HL,SECBUF
	LD	BC,BUFSIZ
RND_BUFFER1:
	CALL	RNDBYTE
	LD	(HL),A
	INC	HL
	DEC	BC
	LD	A,B
	OR	C
	JP	NZ,RND_BUFFER1
	RET

RND_BUFFERX:
	LD	HL,SAVBUF
	LD	BC,BUFSIZ
RND_BUFFERX1:
	CALL	RNDBYTE
	LD	(HL),A
	INC	HL
	DEC	BC
	LD	A,B
	OR	C
	JP	NZ,RND_BUFFERX1
	RET
;
; SAVE_BUFFER
;	
SAVE_BUFFER:
	LD	HL,SECBUF
	LD	DE,SAVBUF
	LD	BC,BUFSIZ
	LDIR
	RET
;
; CMP_BUFFER
;   HL = ADDRESS OF SOURCE BUFFER
;   DE = ADDRESS OF DESTINATION BUFFER
;   BC = SIZE OF BUFFER
;   RETURNS Z IF EQUAL, NZ IF DIFFERENT
;
CMP_BUFFER:
	LD	HL,SECBUF
	LD	DE,SAVBUF
	LD	BC,BUFSIZ

CMP_BUFFER1:
	LD	A,(DE)
	CP	(HL)
	JP	NZ,CMP_BUFFER_MISMATCH
	INC	DE
	INC	HL
	DEC	BC
	LD	A,B
	OR	C
	JP	NZ,CMP_BUFFER1
	RET				; RET W/ Z SET

CMP_BUFFER_MISMATCH:
	PUSH	DE
	LD	DE,STR_MISMATCH
	CALL	WRITESTR
	POP	DE
	LD	A,D
	CALL	PRTHEXBYTE
	LD	A,E
	CALL	PRTHEXBYTE
	LD	A,0FFH
	OR	A			; RET W/ NZ SET
	RET
;
; GENERATE A RANDOM BYTE
;
; RETURNS PSEUDO RANDOM 8 BIT NUMBER IN A. ONLY AFFECTS A.
; (SEED) IS THE BYTE FROM WHICH THE NUMBER IS GENERATED AND MUST BE	
; INITIALIZED TO A NON ZERO VALUE OR THIS FUNCTION WILL ALWAYS RETURN
; ZERO.
;
RB_SEED		.DB	1		; RNDBYTE SEED (MUST NOT BE ZERO)
;
RNDBYTE:
	LD	A,(RB_SEED)	; GET SEED
	AND	0B8H		; MASK NON-FEEDBACK BITS
	SCF			; SET CARRY
	JP	PO,RB_NC	; SKIP CLEAR IF ODD
	CCF			; COMPLEMENT CARRY (CLEAR IT)
RB_NC	LD	A,(RB_SEED)	; GET SEED BACK
	RLA			; ROTATE CARRY INTO BYTE
	LD	(RB_SEED),A	; SAVE BACK FOR NEXT
	RET			; DONE
;
;
;
STR_EMPTY	.TEXT	"<EMPTY>$"
HEXSTRBUF	.TEXT	"XX$"
STR_SRC		.TEXT	"SOURCE: $"
STR_DEST	.TEXT	"DESTINATION: $"
STR_BEFORE	.TEXT	"BEFORE:$"
STR_AFTER	.TEXT	"AFTER:$"
STR_REGS	.TEXT	"REGISTERS: $"
STR_MISMATCH	.TEXT	"\r\n\r\n*** DATA MISMATCH AT $"
STR_IDENTITY	.TEXT	"\r\n\r\nDEVICE IDENTITY DATA:\r\n$"
STR_FILLTEST	.TEXT	"\r\n\r\nPERFORMING FILL TEST...$"
STR_PATTEST	.TEXT	"\r\n\r\nPERFORMING PATTERN TEST...$"
STR_RNDTEST	.TEXT	"\r\n\r\nPERFORMING RANDOM TEST...$"
STR_PROBTEST	.TEXT	"\r\n\r\nPERFORMING PROBLEM BUFFER TEST...$"
STR_SUCCESS	.TEXT	"\r\n\r\nALL TESTS COMPLETED -- NO ERRORS\r\n$"
STR_FAILURE	.TEXT	"\r\n\r\nTEST FAILURE -- REVIEW ERRORS\r\n$"
STR_SAR		.TEXT	" SAR=$"
STR_DAR		.TEXT	" DAR=$"
STR_BCR		.TEXT	" BCR=$"
STR_DSTAT	.TEXT	" DSTAT=$"
STR_DMODE	.TEXT	" DMODE=$"
STR_DCNTL	.TEXT	" DCNTL=$"

SECBUF		.EQU	0A000H
SAVBUF		.EQU	0B000H
BUFSIZ		.EQU	00200H

STACKSAV	.DW	0
STACKSIZ	.EQU	40H		; WE ARE A STACK PIG
		.FILL	STACKSIZ,0
STACK		.EQU	$

	.END